# Pod的生命周期

## The life of a Pod 

Pod被设计成为一种生命周期短暂的单位。其基本的生命周期基本可以概括为 创建，分配一个唯一的ID，安排到工作节点上去，然后在这个节点上一直呆到最后被销毁。 如果这个工作机器本身出现故障，并且在规定时间内也没能恢复，接下来我们就着手安排去删掉这个Pod。

一旦Pod被创建以后，它是不能被迁移到别的工作机器上去的。 我们只会在别的机器上去创建一个一模一样的Pod, 连Pod名字都能保证一样，但是IP会是新的IP。 

根据你的设置，内存片段可以跟Pod拥有同样的生命周期，也就是Pod被重建以后内存也会是完全崭新的内存。 根据之前所说，同样也可以做到Pod被删除以后内存保留下来。

## 销毁一个Pod的过程是怎样的

考虑到Pod本质上是系统里的一个进程，进程总会要结束的，不能一直运行着。那么相比较于直接发送一个`KILL`信号，也不给一点Clean Up时间， 我们还是希望能清理干净以后再清理这个pod。所以你作为管理者你就需要知道如何去正确的销毁一个pod，知道什么时候这个pod已经被销毁了，你还要知道怎么去确认这个pod已经被销毁了。

当用户发送了一个销毁请求的时候，在强制销毁之前，系统会记录下一个既定好的缓冲时间。首先我们会向pod内每一个容器发送一个`TERM`信号。等缓冲时间一过，我们就朝所有的主进程发送KILL信号， 此时这个pod就从`API Server`中被删掉了。如果在缓冲期内kubelet发生重启，那么重启结束会重新尝试删除。

1. 用户发送销毁相关的命令，默认的缓冲时间是30秒
2. 系统通过`API-Server`收到相关销毁指令，系统记录下此事件以及缓冲时间。超过了缓冲时间，这个Pod就会被认为“已经销毁” ， 并在`etcd`\(系统信息\)中移除这个pod的相关信息
3. 在客户端指令中再次查看这个pod，它的状态变成了`Terminating`
4. \(与3同步发生\) API-Server因为已经记录下这次操作，因此当Kubelet看到了这种标记的时候，Kubelet开始着手清理自己管理着的pod
   1. Pod内所有容器收到一个`TERM`信号
   2. 如果Pod内存在有一个`preStop`工件，并且`preStop`在缓冲期结束仍旧在运行，API-Server中会记录下`preStop`的标志，并且将缓冲期延长两秒
5. \(与3同步发生\) 将这个Pod从可提供服务的列表中删除，`replication controller` 记录下这个pod不再是一个运行中的pod。`Load Balancer` 不再给这个pod分配任务
6. 缓冲期结束，向pod内所有进程发送`SIGKILL` 信号
7. Kubetlet意识到销毁过程已经结束，通过API-Server将缓冲时间重新设置为0，象征销毁过程终止，同时将这个Pod从`etcd`\(系统信息\)中永久移除，此时从客户端我们将不能再看到这个pod

#### 终止相关的指令

* `kubelet delelte --grace-period=<seconds>` 手动设置缓冲时间
  * `seconds = 0`强制删除命令，API-Server一旦收到强制删除命令根本就不会等Kubelet确认，因为seconds=0本身就是由kubelet来设置的，所以你设置seconds=0相当于模拟出了Kubelet通过API-Server将缓冲时间设置为0这一步，直接来到etcd删除掉相关信息这一步骤。
  * 同时Kubelet则向自己的pod直接发送`SIGKILL`信号



> 介绍kubelet/etcd/API-SERVER
>
> api与api-server什么关系
>
> > API与系统信息是什么关系



